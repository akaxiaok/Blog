###null合并运算符
==??== 运算符称作null 合并运算符。如果此运算符的左操作数不为null，则此运算符将返回左操作数；否则返回右操作数。

###使用Average而产生的一个错误
``` cs
	decimal? avgUPri = dt.AsEnumerable().Average(q => q.Field<decimal?>("单价"));
```


###ref、out
out参数比较简单，加了之后就不需要先申明变量了。
ref参数使用引用变量时，有些要注意的地方。如果只改变引用对象的成员，那么用不用ref都是一样的效果，但如果要将引用对象进行重新赋值，要得到新的引用的对象，就必须使用ref了，否则不能改变对象。

###断言
请不要将函数调用放在 Debug.Assert 语句中。改用临时变量

###List


ArrayList  //存储对象，当存储值类型数据时需要装箱，消耗较大。一个ArrayList可以存储不同的数据类型
Array&lt;T&gt; //指定泛型，不需要装箱、拆箱


###泛型
优点：算法重用、类型安全、相比object没有拆箱、装箱的性能损耗


泛型约束where:，可以约束接口、基类、类型、默认构造函数()

MyClass&lt;T&gt;where T : IComparable&lt;T&gt; //约束T必须实现IComparable接口、基类同理
where T : class   //约束T类型必须为引用类型
where T : struct  //约束T类型必须为值类型
where T:new() //约束T类型有一个公共无参构造器

###协变、抗变
逆变：
泛型类型T可以从基类型更改为该类的派生类型，
用in关键字标记逆变形式的类型参数，
而且这个参数一般作输入参数。

协变：
泛型类型T可以从派生类型更改为它的基类型，
用out关键字来标记协变形式的类型参数，
而且这个参数一般作为返回值

如果我们定义了一个这样的委托：
public delegate TResult MyAction&lt;in T&gt;,out TResult&gt;(T obj);

那么，就可以让如下代码通过编译（不用强制转换）

var a = new MyAction&lt;object, ArgumentException&gt;(o => new ArgumentException(o.ToString()));
MyAction&lt;string, Exception&gt; b = a;


###线程
做foreach循环时多考虑线程安全性

在foreach时不要试图对被遍历的集合进行remove和add等操作

任何集合，即使被标记为线程安全的，在foreach的时候，增加项和移除项的操作都会导致异常
###linq
```cs
from [type] id in source
[join [type] id in source on expr equals expr [into subGroup]]
[from [type] id in source | let id = expr | where condition]
[orderby ordering,ordering,ordering...]
select expr | group expr by key
[into id query]
```