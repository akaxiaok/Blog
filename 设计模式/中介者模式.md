[TOC]
## 意图
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。
## 适用性
- 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
- 一个对象引用其他很多对象并且之间
- 想定制一个分布在多个类中的行为，而又不想生成太多子类。

## 结构
![](http://images.cnblogs.com/cnblogs_com/castdream/758571/o_ScreenClip%20[2].png)
## 实现
在未来的智能家居中，家里的各种电器相互关联，假设这样三种电器：闹钟，日历和咖啡壶。现在有这样两个任务：
1. 当按下闹钟的“延迟”按钮（过5分钟后再次响铃）后，日历检查今天是否是星期日，如果不是，则咖啡壶开始准备咖啡。
2. 当关闭日历，咖啡壶和闹钟也一同关闭。



同事类，每一个同事都知道他的中介者，当它需要与其他同事交流时，它只需通知中介者。
``` cs
public abstract class Colleague
    {
        protected string _type;
        protected Mediator _theMediator;
        public string Type
        {
            get { return _type; }
        }
        public Mediator TheMediator
        {
            get { return _theMediator; }
            set { _theMediator = value; }
        }
    }
```
具体同事
``` cs
  public class Alarm : Colleague
    {
        public Alarm()
        {
            _type = "Alarm";
        }
        public void AlarmLater()
        {
            Console.WriteLine("Alarm 5min later");
            _theMediator.Notify(this);
        }
        public void PowerOff()
        {
            Console.WriteLine("Alarm PowerOff");
        }
    }
	public class CoffeePot : Colleague
    {
        public CoffeePot()
        {
            _type = "CoffeePot";
        }
        public void PrepareCoffee()
        {
            Console.WriteLine("Start preparing coffee");
        }
        public   void PowerOff()
        {
            Console.WriteLine("CoffeePot PowerOff");
        }
    }
	 public class Calendar : Colleague
    {
        public Calendar()
        {
            _type = "Calendar";
        }
        public DayOfWeek GetDayOfWeek()
        {
            return DateTime.Today.DayOfWeek;
        }
        public  void PowerOff()
        {
            Console.WriteLine("Calendar PowerOff");
            _theMediator.Notify(this);
        }
    }
```
中介者定义一个用于与各同事通信的接口
``` cs
  public  class Mediator
    {
        public virtual void Notify(Colleague colleague)
        {
        }
    }
```
具体中介者了解和维护各个同事，并协调各同事以实现协作行为。
``` cs
 public class FutureHouse : Mediator
    {
        private Alarm _alarm;
        private CoffeePot _coffeePot;
        private Calendar _calendar;
        public Calendar HouseCalendar
        {
            get { return _calendar; }
            set { _calendar = value; }
        }
        public CoffeePot HouseCoffeePot
        {
            get { return _coffeePot; }
            set { _coffeePot = value; }
        }
        public Alarm HouseAlarm
        {
            get { return _alarm; }
            set { _alarm = value; }
        }
        private void WeekUp()
        {
            if (HouseCalendar.GetDayOfWeek()!=DayOfWeek.Sunday)
            {
                HouseCoffeePot.PrepareCoffee();
            }
        }
        private void PowerOff()
        {
            HouseCoffeePot.PowerOff();
            HouseAlarm.PowerOff();
        }
        public override void Notify(Colleague colleague)
        {
            if (colleague.Type == "Alarm")
            {
                WeekUp();
            }
            else if (colleague.Type == "Calendar")
            {
                PowerOff();
            }
        }
    }
```
使用
``` cs
class Program
    {
        static void Main(string[] args)
        {
            var calendar = new Calendar();
            var coffeePot = new CoffeePot();
            var alarm = new Alarm();
            var house = new FutureHouse();
            calendar.TheMediator = house;
            alarm.TheMediator = house;
            coffeePot.TheMediator = house;

            house.HouseCalendar = calendar;
            house.HouseAlarm = alarm;
            house.HouseCoffeePot = coffeePot;

            alarm.AlarmLater();

            calendar.PowerOff();

            Console.ReadKey();
        }
    }
```
运行结果
- 周日
![](http://images.cnblogs.com/cnblogs_com/castdream/758573/o_nocoff.png)
- 非周日
![](http://images.cnblogs.com/cnblogs_com/castdream/758573/o_coff.png)

## 效果
1. 减少了子类
2. 将各Colleague解耦
3. 简化了对象协议，使用Mediator和各Colleague间的一对多交互替代多对多交互
4. 它对对象如何进行协助进行了抽象
5. 使控制集中化
6. 中介者可能变得庞大而且复杂，难以维护

## 参考
1. [《Head First 设计模式》](http://book.douban.com/subject/2243615/)
2. [《设计模式》](http://book.douban.com/subject/1052241/)