[TOC]
###意图
动态的给一个对象添加一些额外的职责。
###适用性
- 动态的为单个对象添加职责而不影响其他对象
- 处理那些可以撤销的职责（? 在某些功能不需要时删除这些功能）
- 当不能采用生成子类的方法进行扩展时

###结构
![装饰器模式UML](http://images.cnblogs.com/cnblogs_com/castdream/758571/o_decorator.png)

###实现
设计一些饮料，这些饮料可以由顾客选择添加各种佐料。
先是饮料的抽象类
```cs
 abstract class Beverage
    {
        protected  string Description = "Unknown Beverage";
        public virtual string GetDescription()
        {
            return Description;
        }
        public abstract double Cost();
    }
```
接下来是具体的饮料类
```cs
 class Coffee:Beverage
    {
        public Coffee()
        {
            Description = "coffee";
        }
        override public double Cost()
        {
            return 1.99;
        }
    }
```
然后是装饰器的抽象类，它不仅继承了饮料的抽象，而且还它包含一个饮料成员
```cs
abstract class CondimentDecorator : Beverage
    {
        protected Beverage Beverage;
        override public abstract string GetDescription();
    }
```
最后是两个具体的装饰器
```cs
    class Milk:CondimentDecorator
    {
        public Milk(Beverage beverage)
        {
            this.Beverage = beverage;
        }
        override public string GetDescription()
        {
            return "Milk " + Beverage.GetDescription();
        }
        override public double Cost()
        {
            return .10 + Beverage.Cost();
        }
    }


	   class Mocha:CondimentDecorator
    {
        public Mocha(Beverage beverage)
        {
            this.Beverage = beverage;
        }
        override public string GetDescription()
        {
            return "Mocha " + Beverage.GetDescription();
        }
        override public double Cost()
        {
            return .20 + Beverage.Cost();
        }
    }
```
现在，顾客可以随意选择佐料了
```cs
   class Program
    {
        static void Main(string[] args)
        {
            Beverage beverage = new Coffee();
            Console.WriteLine(beverage.GetDescription() + ": $" + beverage.Cost());
            Beverage mocha = new Mocha(beverage);
            Console.WriteLine(mocha.GetDescription() + ": $" + mocha.Cost());
            Beverage milk = new Milk(beverage);
            Console.WriteLine(milk.GetDescription() + ": $" + milk.Cost());
            Beverage mochaMilk = new Milk(mocha);
            Console.WriteLine(mochaMilk.GetDescription() + ": $" + mochaMilk.Cost());
            Console.ReadKey();
        }
    }
```
运行结果
 ![运行结果](http://images.cnblogs.com/cnblogs_com/castdream/758573/o_Unnamed%20QQ%20Screenshot20151213134453.png)
###效果
1.比静态继承灵活
2.避免在层次结构高层的类有太多的特征
3.装饰器与它装饰的对象不一样，使用时不能依赖对象表示
4.会产生许多小对象


###参考
1. [《Head First 设计模式》](http://book.douban.com/subject/2243615/)
2. [《设计模式》](http://book.douban.com/subject/1052241/)
