a[n]为待排序的数组
[0,n]表示从0（含0）到n（含n）即(int i = 0; i&lt;=n;i++)

[0,n)表示从0（含0）到n（不含n）即(int i = 0; i&lt;n;i++)
###冒泡排序
```cs
for i= [0,n-1)
{
	for j = [0,n-1-i)
        {
        	if a[j] > a[j+1]
        	swap a[i],a[j+1]
        }
}
```

###选择排序
```cs
for i=[0,n-1)
{
	min=i
        for j = [i+1,n)
        {
        	if a[min] > a[j]
        	min = j;
        }
	swap a[i],a[min]
}
```

###插入排序
```cs
for i = [1,n)
{
	key = a[i]
	j = i-1
	while j >= 0 and key < a[j]
	{
		a[j+1] = a[j]
		j--
	}
	a[j+1] = key
}
```

###归并排序
```cs
MergeSort(a, first, last)
{
	if(first < last)
	{
		int mid  = (first+last) / 2
		MergeSort(a, first, last)
		MergeSort(a, mid + 1, last)
		Merge(a, first, mid, last)
	}
}
Merge(a, first, mid, last)
{
	list = a;//将数组拷贝一份
	i = first, j = mid + 1
	for k=[first,last]
	{
		if (i > mid)//左列已经用完
		{
		    a[k] = list[j++];
		}
		else if (j > last)//右列已经用完
		{
		    a[k] = list[i++];
		}
		else if (list[i] < list[j])//左列比右列小,取左列
		{
		    a[k] = list[i++];
		}
		else//左列比右大,取右列
		{
		    a[k] = list[j++];
		}
	}
}
```
###快速排序
```cs
QuickSort(a,first,last)
{
	if first >= last
	{
		return
	}
	else
	{
		j = Partition(a, first, last)
		QuickSort(a, first, j - 1)
		QuickSort(a, j + 1, last)
	}
}

Partition(a, first, last)
{
	i = first
	j = last + 1
	v = a[first]
	while true
	{
		while a[++i] < v //从左到右
			if i == last break
		while v < a[--j] //从右到左
			if j == first break
		if i >= j break
		swap a[i], a[j]
	}
	return j
}
```
###计数排序
```cs
Count()
{
	int[] b[n + 1]
	int[] c[a.max + 1]
	for i=[0, n)
		c[a[i]] = c[a[i]] + 1
	for i=[1, a.max + 1)
		c[i]  = c[i] + c[i-1]
	for i=[0,n)
		b[c[a[i]]] = a[i]
		c[a[i]] = c[a[i]]-1
}
Count()
{
	List<int> list
	int[] c[a.max + 1]
	for i=[0, n)
		c[a[i]] = c[a[i]] + 1
	for i=[0,c.length)
	{
		if c[i] > 0
		{
			for j=[0,c[i])
			list.add[i]
		}
	}
}
```
